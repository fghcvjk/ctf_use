##### 2020年全国电信和互联网行业网络安全管理职业技能竞赛

###### circuit3

```
import socketserver
from os import urandom
from random import shuffle

wire = []
wire_num = 0
gate_num = 0
input_A_len = 0
input_B_len = 0
output_len = 0

def cf_run(input_A, input_B, cpath):
    with open(cpath, 'r') as cf:
        nums = cf.readline()
        _, wire_num = nums.strip().split(" ")
        wire_num = int(wire_num)
        wire = [0 for i in range(wire_num)]

        nums = cf.readline()
        input_A_len, input_B_len, output_len = nums.strip().split(" ")
        input_A_len = int(input_A_len)
        input_B_len = int(input_B_len)
        output_len = int(output_len)

        assert len(input_A)*8 == input_A_len
        assert len(input_B)*8 == input_B_len

        for i in range(len(input_A)):
            for j in range(8):
                wire[8*i + j] = (input_A[i] >> j) & 1

        for i in range(len(input_B)):
            for j in range(8):
                wire[input_A_len + 8*i + j] = (input_B[i] >> j) & 1
        
        cf.readline()

        for gateline in cf:
            gate = gateline.strip().split(" ")
            if gate[4] == 'INV':
                if wire[int(gate[2])] == 0:
                    wire[int(gate[3])] = 1
                elif wire[int(gate[2])] == 1:
                    wire[int(gate[3])] = 0
                else:
                    print("error!!!")
                    break
            elif gate[5] == "AND":
                wire[int(gate[4])] = wire[int(gate[3])] & wire[int(gate[2])]
            elif gate[5] == "XOR":
                wire[int(gate[4])] = wire[int(gate[3])] ^ wire[int(gate[2])]
            else:
                print("error!!!")
                break
        
        output = ""
        for i in range(output_len):
            output += str(wire[-(output_len - i)])
        
        return output

class process(socketserver.BaseRequestHandler):
    def send(self, s):
        s = str(s)
        self.request.send(bytes(s, 'utf-8'))
    
    def handle(self):
        key = urandom(32)
        self.send("---start---")
        self.send("Give me your token\n")
        token = self.request.recv(21).strip()

        self.send("Give me the circuit file's length.\n")
        l = self.request.recv(7).strip()
        length = 0
        try:
            length = int(l)
        except Exception:
            self.send("---end---")
            self.request.close()
            return
        if length > 50000:
            self.send("---end---")
            self.request.close()
            return

        self.send("Give me the circuit file.\n")
        data = self.request.recv(length)
        
        cpath = str(token) + "circuit.txt"
        with open(cpath, 'wb') as f:
            f.write(data)
        
        res = cf_run(key, key, cpath)
        if res != "10000000000000000000000000000000":
            self.send("---end---")
            self.request.close()
            return

        for _ in range(100):
            x = urandom(32)
            res = cf_run(key, x, cpath)
            if res != "11111111111111111111111111111111":
                self.send("---end---")
                self.request.close()
                return
        
        self.send("Give me the key to unlock the flag.\n:>>")
        k = self.request.recv(33).strip()
        res = cf_run(key, k, cpath)
        if res != "10000000000000000000000000000000":
            self.send("---end---")
            self.request.close()
            return

        with open("flag.txt", 'r') as f:
            flag = f.readline()
            self.send(flag)
        self.send("---end---")
        self.request.close()
        return

class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    pass

if __name__ == "__main__":
    HOST, PORT = '0.0.0.0', 10086
    server = ThreadedServer((HOST, PORT), process)
    server.allow_reuse_address = True
    server.serve_forever()
```

###### crypto_lp

```
class Unbuffered(object):
   def __init__(self, stream):
       self.stream = stream
   def write(self, data):
       self.stream.write(data)
       self.stream.flush()
   def __getattr__(self, attr):
       return getattr(self.stream, attr)
import sys
sys.stdout = Unbuffered(sys.stdout)
import os
from Crypto.Cipher import AES
from Crypto.Util.number import *
import random

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def invert(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

os.chdir("/home/ctf")
flag=open("flag","rb").read()
p=getPrime(512)
q=getPrime(512)
n=p*q
e=0x10001
d=invert(e,(p-1)*(q-1))
secret=os.urandom(32)
pp=getPrime(512)
qq=getPrime(512)
nn=pp*qq
dd=invert(e,(pp-1)*(qq-1))



def u():
    secret=os.urandom(32)

def l():
    m=bytes_to_long(secret)
    c=pow(m,e,n)
    print c

def p():
    rc=int(raw_input())
    if rc!=pow(bytes_to_long(secret),e,n):
        print pow(rc,d,n)

def o():
    rs=int(raw_input())
    if rs==bytes_to_long(secret):
        rc=int(raw_input())
        print pow(rc,dd,nn)%2


def run():
    print "llp"
    print n
    print nn
    print pow(bytes_to_long(flag),e,nn)
    while 1:
        choice=raw_input(">")
        if choice=="u":
            u()
        elif choice=="l":
            l()
        elif choice=="p":
            p()
        elif choice=="o":
            o()
        else:
            print "wrong"



if __name__ == '__main__':
    run()
```

