##### 2020年全国电信和互联网行业网络安全管理职业技能竞赛

###### circuit3

```
import socketserver
from os import urandom
from random import shuffle

wire = []
wire_num = 0
gate_num = 0
input_A_len = 0
input_B_len = 0
output_len = 0

def cf_run(input_A, input_B, cpath):
    with open(cpath, 'r') as cf:
        nums = cf.readline()
        _, wire_num = nums.strip().split(" ")
        wire_num = int(wire_num)
        wire = [0 for i in range(wire_num)]

        nums = cf.readline()
        input_A_len, input_B_len, output_len = nums.strip().split(" ")
        input_A_len = int(input_A_len)
        input_B_len = int(input_B_len)
        output_len = int(output_len)

        assert len(input_A)*8 == input_A_len
        assert len(input_B)*8 == input_B_len

        for i in range(len(input_A)):
            for j in range(8):
                wire[8*i + j] = (input_A[i] >> j) & 1

        for i in range(len(input_B)):
            for j in range(8):
                wire[input_A_len + 8*i + j] = (input_B[i] >> j) & 1
        
        cf.readline()

        for gateline in cf:
            gate = gateline.strip().split(" ")
            if gate[4] == 'INV':
                if wire[int(gate[2])] == 0:
                    wire[int(gate[3])] = 1
                elif wire[int(gate[2])] == 1:
                    wire[int(gate[3])] = 0
                else:
                    print("error!!!")
                    break
            elif gate[5] == "AND":
                wire[int(gate[4])] = wire[int(gate[3])] & wire[int(gate[2])]
            elif gate[5] == "XOR":
                wire[int(gate[4])] = wire[int(gate[3])] ^ wire[int(gate[2])]
            else:
                print("error!!!")
                break
        
        output = ""
        for i in range(output_len):
            output += str(wire[-(output_len - i)])
        
        return output

class process(socketserver.BaseRequestHandler):
    def send(self, s):
        s = str(s)
        self.request.send(bytes(s, 'utf-8'))
    
    def handle(self):
        key = urandom(32)
        self.send("---start---")
        self.send("Give me your token\n")
        token = self.request.recv(21).strip()

        self.send("Give me the circuit file's length.\n")
        l = self.request.recv(7).strip()
        length = 0
        try:
            length = int(l)
        except Exception:
            self.send("---end---")
            self.request.close()
            return
        if length > 50000:
            self.send("---end---")
            self.request.close()
            return

        self.send("Give me the circuit file.\n")
        data = self.request.recv(length)
        
        cpath = str(token) + "circuit.txt"
        with open(cpath, 'wb') as f:
            f.write(data)
        
        res = cf_run(key, key, cpath)
        if res != "10000000000000000000000000000000":
            self.send("---end---")
            self.request.close()
            return

        for _ in range(100):
            x = urandom(32)
            res = cf_run(key, x, cpath)
            if res != "11111111111111111111111111111111":
                self.send("---end---")
                self.request.close()
                return
        
        self.send("Give me the key to unlock the flag.\n:>>")
        k = self.request.recv(33).strip()
        res = cf_run(key, k, cpath)
        if res != "10000000000000000000000000000000":
            self.send("---end---")
            self.request.close()
            return

        with open("flag.txt", 'r') as f:
            flag = f.readline()
            self.send(flag)
        self.send("---end---")
        self.request.close()
        return

class ThreadedServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    pass

if __name__ == "__main__":
    HOST, PORT = '0.0.0.0', 10086
    server = ThreadedServer((HOST, PORT), process)
    server.allow_reuse_address = True
    server.serve_forever()
```

###### crypto_lp

```
class Unbuffered(object):
   def __init__(self, stream):
       self.stream = stream
   def write(self, data):
       self.stream.write(data)
       self.stream.flush()
   def __getattr__(self, attr):
       return getattr(self.stream, attr)
import sys
sys.stdout = Unbuffered(sys.stdout)
import os
from Crypto.Cipher import AES
from Crypto.Util.number import *
import random

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def invert(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

os.chdir("/home/ctf")
flag=open("flag","rb").read()
p=getPrime(512)
q=getPrime(512)
n=p*q
e=0x10001
d=invert(e,(p-1)*(q-1))
secret=os.urandom(32)
pp=getPrime(512)
qq=getPrime(512)
nn=pp*qq
dd=invert(e,(pp-1)*(qq-1))



def u():
    secret=os.urandom(32)

def l():
    m=bytes_to_long(secret)
    c=pow(m,e,n)
    print c

def p():
    rc=int(raw_input())
    if rc!=pow(bytes_to_long(secret),e,n):
        print pow(rc,d,n)

def o():
    rs=int(raw_input())
    if rs==bytes_to_long(secret):
        rc=int(raw_input())
        print pow(rc,dd,nn)%2


def run():
    print "llp"
    print n
    print nn
    print pow(bytes_to_long(flag),e,nn)
    while 1:
        choice=raw_input(">")
        if choice=="u":
            u()
        elif choice=="l":
            l()
        elif choice=="p":
            p()
        elif choice=="o":
            o()
        else:
            print "wrong"



if __name__ == '__main__':
    run()
```

##### 中国科学技术大学第七届信息安全大赛

###### 233 同学的字符串工具

```
import re

def to_upper(s):
    r = re.compile('[fF][lL][aA][gG]')
    if r.match(s):
        print('how dare you')
    elif s.upper() == 'FLAG':
        print('yes, I will give you the flag')
        print(open('/flag1').read())
    else:
        print('%s' % s.upper())

def to_utf8(s):
    r = re.compile('[fF][lL][aA][gG]')
    s = s.encode() # make it bytes
    if r.match(s.decode()):
        print('how dare you')
    elif s.decode('utf-7') == 'flag':
        print('yes, I will give you the flag')
        print(open('/flag2').read())
    else:
        print('%s' % s.decode('utf-7'))

def main():
    print('Welcome to the best string tool here!')
    print('Brought to you by 233 PROUDLY')
    print('')
    print('Which tool do you want?')
    print('1. Convert my string to UPPERCASE!!')
    print('2. Convert my UTF-7 string to UTF-8!!')
    choice = input()
    if choice[0] == '1':
        print('Welcome to the capitalizer tool, please input your string: ')
        to_upper(input())
    elif choice[0] == '2':
        print('Welcome to the UTF-7->UTF-8 tool, please input your string: ')
        to_utf8(input())
    else:
        print('I am confused, madam')

main()
```

###### 不经意传输

```
from Crypto.PublicKey import RSA
from random import SystemRandom
import os


if __name__ == "__main__":
    random = SystemRandom()

    key = RSA.generate(1024)
    print("n =", key.n)
    print("e =", key.e)

    m0 = int.from_bytes(os.urandom(64).hex().encode(), "big")
    m1 = int.from_bytes(os.urandom(64).hex().encode(), "big")

    x0 = random.randrange(key.n)
    x1 = random.randrange(key.n)
    print("x0 =", x0)
    print("x1 =", x1)

    v = int(input("v = "))
    m0_ = (m0 + pow(v - x0, key.d, key.n)) % key.n
    m1_ = (m1 + pow(v - x1, key.d, key.n)) % key.n
    print("m0_ =", m0_)
    print("m1_ =", m1_)

    guess0 = int(input("m0 = "))
    guess1 = int(input("m1 = "))
    if guess0 == m0:
        print(open("flag1").read())
        if guess1 == m1:
            print(open("flag2").read())
    else:
        print("Nope")
```

###### 超自动的开箱模拟器

```
from collections import deque
from random import SystemRandom


class BF:
    def __init__(self, code):
        self.code = code
        self.output = deque()
        self.input = deque()
        self.data = [0]
        self.codeptr = 0
        self.dataptr = 0
        self.generate_map()

    def generate_map(self):
        self.map = {}
        stack = []
        for i, op in enumerate(self.code):
            if op == "[":
                stack.append(i)
            elif op == "]":
                if not stack:
                    print("Error: Brackets not matching")
                    exit(-1)
                pos = stack.pop()
                self.map[pos] = i
                self.map[i] = pos
        if stack:
            print("Error: Brackets not matching")
            exit(-1)

    def step(self):
        op = self.code[self.codeptr]
        if op == ">":
            self.dataptr += 1
            if self.dataptr == len(self.data):
                self.data.append(0)
        elif op == "<":
            if self.dataptr:
                self.dataptr -= 1
        elif op == "+":
            self.data[self.dataptr] += 1
            self.data[self.dataptr] %= 256
        elif op == "-":
            self.data[self.dataptr] -= 1
            self.data[self.dataptr] %= 256
        elif op == "[":
            if self.data[self.dataptr] == 0:
                self.codeptr = self.map[self.codeptr]
        elif op == "]":
            if self.data[self.dataptr] != 0:
                self.codeptr = self.map[self.codeptr]
        elif op == ".":
            self.output.append(self.data[self.dataptr])
        elif op == ",":
            if not self.input:
                print("Error: No input")
                exit(-1)
            self.data[self.dataptr] = self.input.popleft()
        self.codeptr += 1

    def run_till_output(self):
        while self.codeptr < len(self.code):
            self.step()
            if self.output:
                return self.output.popleft()
        return None


class Game:
    def __init__(self, nboxes, nguess):
        self.nboxes = nboxes
        self.nguess = nguess
        rnd = SystemRandom()
        self.boxes = list(range(1, nboxes + 1))
        rnd.shuffle(self.boxes)

    def play_one_round(self, target, code):
        bf = BF(code)
        bf.input.append(target)
        box_key = 0
        guesses = 0
        while guesses < self.nguess:
            out = bf.run_till_output()
            if out is None:
                print("Error: No enough output after BF ended")
                exit(-1)
            if out == 1:  # move left
                if box_key > 0:
                    box_key -= 1
            elif out == 2:  # move right
                if box_key < self.nboxes - 1:
                    box_key += 1
            elif out == 3:  # open current box
                guesses += 1
                box_value = self.boxes[box_key]
                print(f"- Guess {guesses}/{self.nguess}: {box_key}->{box_value}")
                if box_value == target:
                    print("Target found")
                    return True
                bf.input.append(box_value)
        print(f"Target not found after {self.nguess} guesses")
        return False

    def play(self, code):
        for i in range(1, self.nboxes + 1):
            print(f"Running round {i}/{self.nboxes}, target = {i}")
            if not self.play_one_round(i, code):
                return False
        return True


if __name__ == "__main__":
    code = input("Your unboxing BF code: ")
    game = Game(128, 64)
    if game.play(code):
        print("You win")
        print(open("flag").read())
    else:
        print("You lose")
```

###### 从零开始的火星文生活

```
脦脪鹿楼脝脝脕脣 拢脠拢谩拢茫拢毛拢氓拢貌拢莽拢谩拢铆拢氓 碌脛路镁脦帽脝梅拢卢脥碌碌陆脕脣脣眉脙脟碌脛 拢忙拢矛拢谩拢莽拢卢脧脰脭脷脦脪掳脩 拢忙拢矛拢谩拢莽 路垄赂酶脛茫拢潞
拢忙拢矛拢谩拢莽拢没拢脠拢麓拢枚拢鲁拢脽拢脝拢玫拢脦拢脽拢梅拢卤拢脭拢猫拢脽拢鲁拢卯拢茫拢掳拢盲拢卤拢卯拢莽拢脽拢麓拢脦拢盲拢脽拢盲拢鲁拢茫拢掳拢脛拢卤拢卯拢脟拢脽拢鹿拢帽拢脛拢虏拢脪拢赂拢猫拢贸拢媒
驴矛脠楼卤脠脠眉脝陆脤篓脤谩陆禄掳脡拢隆
虏禄脪陋脭脵掳脩脮芒路脻脨脜脧垄脳陋路垄赂酶脝盲脣没脠脣脕脣拢卢脪陋脢脟卤禄路垄脧脰戮脥脭茫赂芒脕脣拢隆
```

###### 从零开始的记账工具人

```
拾陆元玖角叁分	1
```

###### 证验码

```
import numpy as np
from PIL import ImageFont, ImageDraw, Image
from matplotlib import pyplot as plt
import pathlib

import string
from random import SystemRandom
random = SystemRandom()

alphabet = sorted(string.digits + string.ascii_letters)

def img_generate(text):
    img = Image.new('RGB', (40 * len(text), 100), (255, 255, 255))
    # https://github.com/adobe-fonts/source-code-pro/raw/release/TTF/SourceCodePro-Light.ttf
    fontpath = pathlib.Path(__file__).parent.absolute().joinpath("SourceCodePro-Light.ttf")
    font = ImageFont.truetype(str(fontpath), 64)
    draw = ImageDraw.Draw(img)
    draw.text((0, 0), text, font = font, fill = (0,0,0,0))
    return img


def add_noise(draw, size):
    def get_random_xy(draw):
        x = random.randint(0, size[0])
        y = random.randint(0, size[1])
        return x, y
    
    def get_random_color():
        r = random.randint(0, 256)
        g = random.randint(0, 256)
        b = random.randint(0, 256)
        return r, g, b
    
    draw.line([get_random_xy(draw), get_random_xy(draw)], 
                get_random_color(), width=1)


def shuffle(img):
    pix = np.array(img)
    x, y, z = pix.shape
    t = pix.reshape(-1, z).tolist()
    random.shuffle(t)
    pix_shuffled = np.array(t, dtype=np.uint8).reshape(x, y, z)
    return Image.fromarray(pix_shuffled)


def generate_captcha(code, shuffle_mode=False):
    img = img_generate(code)
    draw = ImageDraw.Draw(img)
    for _ in range(10):
        add_noise(draw, size=img.size)

    if shuffle_mode:
        return shuffle(img)
    else:
        return img

if __name__ == "__main__":
    code = "".join([random.choice(alphabet) for _ in range(16)])
    print("Code:", code)

    img_orig = generate_captcha(code, shuffle_mode=False)
    img_orig.save('captcha.bmp')

    img_shuffled = generate_captcha(code, shuffle_mode=True)
    img_shuffled.save('captcha_shuffled.bmp')
```

###### 中间人

```
#!/usr/bin/env python3

from Crypto.Cipher import AES
import os
from hashlib import sha256
from utils import *


def talk_to_Alice():
    name = bytes.fromhex(input("What's your name? "))
    extra = bytes.fromhex(input("What else do you want to say? "))
    msg = b"Thanks " + name + b" for taking my flag: " + flag + extra
    plaintext = msg + sha256(msg).digest()
    iv = os.urandom(AES.block_size)
    aes = AES.new(AES_key, AES.MODE_CBC, iv)
    print("This is my encrypted message, please take it to Bob:")
    print((iv + aes.encrypt(pad(plaintext))).hex())


def talk_to_Bob():
    try:
        ciphertext = bytes.fromhex(input("Show me your message from Alice: "))
        iv = ciphertext[: AES.block_size]
        aes = AES.new(AES_key, AES.MODE_CBC, iv)
        plaintext = unpad(aes.decrypt(ciphertext[AES.block_size :]))
        assert sha256(plaintext[:-32]).digest() == plaintext[-32:]
        print("Thanks")
    except:
        print("What's your problem???")


if __name__ == "__main__":
    flag = open("flag1").read().encode()
    AES_key = os.urandom(16)
    while True:
        choice = input("Whom do you want to talk to? ")
        if choice == "Alice":
            talk_to_Alice()
        elif choice == "Bob":
            talk_to_Bob()
```

